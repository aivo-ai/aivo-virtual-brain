import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies'
import { Queue } from 'workbox-background-sync'
import { ExpirationPlugin } from 'workbox-expiration'

// Type declarations for service worker
interface ServiceWorkerGlobalScopeExtended extends ServiceWorkerGlobalScope {
  __WB_MANIFEST: any
  skipWaiting(): void
}

declare const self: ServiceWorkerGlobalScopeExtended

// Cleanup outdated caches
cleanupOutdatedCaches()

// Precache shell assets (generated by build)
precacheAndRoute(self.__WB_MANIFEST)

// Cache strategies for different resource types
// App shell - NetworkFirst for fast loading with fallback
registerRoute(
  ({ request }) => request.destination === 'document',
  new NetworkFirst({
    cacheName: 'app-shell',
    plugins: [
      {
        cacheKeyWillBeUsed: async ({ request }) => {
          // Remove query parameters for consistent caching
          const url = new URL(request.url)
          url.search = ''
          return url.href
        }
      }
    ]
  })
)

// Static assets - Cache first with expiration
registerRoute(
  ({ request }) => 
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'worker',
  new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      })
    ]
  })
)

// Images - Cache first with expiration
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      })
    ]
  })
)

// Lesson manifests and content - Stale while revalidate
registerRoute(
  ({ url }) => url.pathname.includes('/api/lessons') || url.pathname.includes('/api/content'),
  new StaleWhileRevalidate({
    cacheName: 'lesson-content',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
      })
    ]
  })
)

// API calls that should be cached - Stale while revalidate
registerRoute(
  ({ url }) => 
    url.pathname.includes('/api/learner') ||
    url.pathname.includes('/api/assessment') ||
    url.pathname.includes('/api/user'),
  new StaleWhileRevalidate({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 10 * 60, // 10 minutes
      })
    ]
  })
)

// Background sync queues for offline POST requests
const eventCollectorQueue = new Queue('event-collector-queue', {
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request);
      } catch (error) {
        console.error('Failed to replay event collector request:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  }
})

const inferenceQueue = new Queue('inference-queue', {
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request);
      } catch (error) {
        console.error('Failed to replay inference request:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  }
})

// Register routes for POST requests that need background sync
registerRoute(
  ({ url, request }) => 
    url.pathname.includes('/api/event-collector') && request.method === 'POST',
  async ({ event }) => {
    try {
      return await fetch(event.request.clone());
    } catch (error) {
      await eventCollectorQueue.pushRequest({ request: event.request });
      return new Response(JSON.stringify({ queued: true }), {
        status: 202,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
)

registerRoute(
  ({ url, request }) => 
    url.pathname.includes('/api/inference-gateway') && request.method === 'POST',
  async ({ event }) => {
    try {
      return await fetch(event.request.clone());
    } catch (error) {
      await inferenceQueue.pushRequest({ request: event.request });
      return new Response(JSON.stringify({ queued: true }), {
        status: 202,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
)

// Handle offline fallback
registerRoute(
  ({ request }) => request.mode === 'navigate',
  async ({ event }) => {
    try {
      return await fetch(event.request)
    } catch (error) {
      // Return cached shell if available
      const cache = await caches.open('app-shell')
      const cachedResponse = await cache.match('/')
      if (cachedResponse) {
        return cachedResponse
      }
      // Fallback offline page
      return new Response(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Offline - Aivo Virtual Brains</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
                   text-align: center; padding: 20px; color: #333; }
            .offline-icon { font-size: 48px; margin-bottom: 20px; }
          </style>
        </head>
        <body>
          <div class="offline-icon">ðŸ“±</div>
          <h1>You're offline</h1>
          <p>Please check your connection and try again.</p>
        </body>
        </html>
      `, {
        status: 200,
        headers: { 'Content-Type': 'text/html' }
      })
    }
  }
)

async function enforeCacheSizeLimit() {
  const cacheNames = await caches.keys()
  let totalSize = 0
  
  for (const cacheName of cacheNames) {
    const cache = await caches.open(cacheName)
    const requests = await cache.keys()
    
    for (const request of requests) {
      const response = await cache.match(request)
      if (response && response.headers.get('content-length')) {
        totalSize += parseInt(response.headers.get('content-length') || '0')
      }
    }
  }
  
  // If over 45MB, start cleaning oldest entries
  const MAX_CACHE_SIZE = 45 * 1024 * 1024 // 45MB to leave buffer
  if (totalSize > MAX_CACHE_SIZE) {
    // Clean lesson content first (most likely to be refreshed)
    const lessonCache = await caches.open('lesson-content')
    const lessonRequests = await lessonCache.keys()
    
    // Remove oldest 25% of lesson content
    const toRemove = lessonRequests.slice(0, Math.floor(lessonRequests.length * 0.25))
    await Promise.all(toRemove.map(req => lessonCache.delete(req)))
  }
}

// Service worker event handlers
addEventListener('message', (event: MessageEvent) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
})

addEventListener('activate', (event: any) => {
  event.waitUntil(
    (async () => {
      // Clean up old caches
      const cacheNames = await caches.keys()
      const oldCaches = cacheNames.filter(name => 
        !name.includes('app-shell') &&
        !name.includes('static-assets') &&
        !name.includes('images') &&
        !name.includes('lesson-content') &&
        !name.includes('api-cache') &&
        !name.includes('workbox')
      )
      
      await Promise.all(
        oldCaches.map(name => caches.delete(name))
      )

      // Ensure cache size limits (â‰¤50MB total)
      await enforeCacheSizeLimit()
    })()
  )
})

export {}
